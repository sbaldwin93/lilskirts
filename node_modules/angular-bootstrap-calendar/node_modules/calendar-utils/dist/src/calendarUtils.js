"use strict";
var moment = require('moment');
var WEEKEND_DAY_NUMBERS = [0, 6];
var DAYS_IN_WEEK = 7;
var HOURS_IN_DAY = 24;
var MINUTES_IN_HOUR = 60;
var getDaySpan = function (event, offset, startOfWeek) {
    var span = 1;
    if (event.end) {
        var begin = moment(event.start).isBefore(startOfWeek) ? startOfWeek : moment(event.start);
        span = moment(event.end)
            .endOf('day')
            .add(1, 'minute')
            .diff(begin.startOf('day'), 'days');
        if (span > DAYS_IN_WEEK) {
            span = DAYS_IN_WEEK;
        }
    }
    var totalLength = offset + span;
    if (totalLength > DAYS_IN_WEEK) {
        span -= (totalLength - DAYS_IN_WEEK);
    }
    return span;
};
exports.getDayOffset = function (event, startOfWeek) {
    var offset = 0;
    if (moment(event.start).startOf('day').isAfter(moment(startOfWeek))) {
        offset = moment(event.start).startOf('day').diff(startOfWeek, 'days');
    }
    return offset;
};
var isEventIsPeriod = function (_a) {
    var event = _a.event, periodStart = _a.periodStart, periodEnd = _a.periodEnd;
    var eventStart = moment(event.start);
    var eventEnd = moment(event.end || event.start);
    if (eventStart.isAfter(periodStart) && eventStart.isBefore(periodEnd)) {
        return true;
    }
    if (eventEnd.isAfter(periodStart) && eventEnd.isBefore(periodEnd)) {
        return true;
    }
    if (eventStart.isBefore(periodStart) && eventEnd.isAfter(periodEnd)) {
        return true;
    }
    if (eventStart.isSame(periodStart) || eventStart.isSame(periodEnd)) {
        return true;
    }
    if (eventEnd.isSame(periodStart) || eventEnd.isSame(periodEnd)) {
        return true;
    }
    return false;
};
var getEventsInPeriod = function (_a) {
    var events = _a.events, periodStart = _a.periodStart, periodEnd = _a.periodEnd;
    return events.filter(function (event) { return isEventIsPeriod({ event: event, periodStart: periodStart, periodEnd: periodEnd }); });
};
var getWeekDay = function (_a) {
    var date = _a.date;
    var today = moment().startOf('day');
    return {
        date: date,
        isPast: date.isBefore(today),
        isToday: date.isSame(today),
        isFuture: date.isAfter(today),
        isWeekend: WEEKEND_DAY_NUMBERS.indexOf(date.day()) > -1
    };
};
exports.getWeekViewHeader = function (_a) {
    var viewDate = _a.viewDate;
    var start = moment(viewDate).startOf('week');
    var days = [];
    for (var i = 0; i < DAYS_IN_WEEK; i++) {
        var date = start.clone().add(i, 'days');
        days.push(getWeekDay({ date: date }));
    }
    return days;
};
exports.getWeekView = function (_a) {
    var events = _a.events, viewDate = _a.viewDate;
    var startOfWeek = moment(viewDate).startOf('week');
    var endOfWeek = moment(viewDate).endOf('week');
    var eventsMapped = getEventsInPeriod({ events: events, periodStart: startOfWeek, periodEnd: endOfWeek }).map(function (event) {
        var offset = exports.getDayOffset(event, startOfWeek);
        var span = getDaySpan(event, offset, startOfWeek);
        return {
            event: event,
            offset: offset,
            span: span,
            startsBeforeWeek: moment(event.start).isBefore(startOfWeek),
            endsAfterWeek: moment(event.end || event.start).isAfter(endOfWeek)
        };
    }).sort(function (itemA, itemB) {
        var startSecondsDiff = moment(itemA.event.start).diff(moment(itemB.event.start));
        if (startSecondsDiff === 0) {
            var endA = moment(itemA.event.end || itemA.event.start);
            var endB = moment(itemB.event.end || itemB.event.start);
            return moment(endB).diff(endA);
        }
        return startSecondsDiff;
    });
    var eventRows = [];
    var allocatedEvents = [];
    eventsMapped.forEach(function (event, index) {
        if (allocatedEvents.indexOf(event) === -1) {
            allocatedEvents.push(event);
            var rowSpan_1 = event.span + event.offset;
            var otherRowEvents = eventsMapped.slice(index + 1).filter(function (nextEvent) {
                if (allocatedEvents.indexOf(nextEvent) === -1 &&
                    nextEvent.offset >= rowSpan_1 &&
                    rowSpan_1 + nextEvent.span <= DAYS_IN_WEEK) {
                    nextEvent.offset -= rowSpan_1;
                    rowSpan_1 += nextEvent.span + nextEvent.offset;
                    allocatedEvents.push(nextEvent);
                    return true;
                }
            });
            eventRows.push({
                row: [
                    event
                ].concat(otherRowEvents)
            });
        }
    });
    return eventRows;
};
exports.getMonthView = function (_a) {
    var events = _a.events, viewDate = _a.viewDate;
    var start = moment(viewDate).startOf('month').startOf('week');
    var end = moment(viewDate).endOf('month').endOf('week');
    var eventsInMonth = getEventsInPeriod({
        events: events,
        periodStart: start,
        periodEnd: end
    });
    var days = [];
    for (var i = 0; i < end.diff(start, 'days') + 1; i++) {
        var date = start.clone().add(i, 'days');
        var day = getWeekDay({ date: date });
        var events_1 = getEventsInPeriod({
            events: eventsInMonth,
            periodStart: moment(date).startOf('day'),
            periodEnd: moment(date).endOf('day')
        });
        day.inMonth = date.clone().startOf('month').isSame(moment(viewDate).startOf('month'));
        day.events = events_1;
        day.badgeTotal = events_1.length;
        days.push(day);
    }
    var rows = Math.floor(days.length / 7);
    var rowOffsets = [];
    for (var i = 0; i < rows; i++) {
        rowOffsets.push(i * 7);
    }
    return {
        rowOffsets: rowOffsets,
        days: days
    };
};
exports.getDayView = function (_a) {
    var events = _a.events, viewDate = _a.viewDate, hourSegments = _a.hourSegments, dayStart = _a.dayStart, dayEnd = _a.dayEnd, eventWidth = _a.eventWidth, segmentHeight = _a.segmentHeight;
    var startOfView = moment(viewDate)
        .startOf('day')
        .hour(dayStart.hour)
        .minute(dayStart.minute);
    var endOfView = moment(viewDate)
        .endOf('day')
        .startOf('minute')
        .hour(dayEnd.hour)
        .minute(dayEnd.minute);
    var previousDayEvents = [];
    var dayViewEvents = getEventsInPeriod({
        events: events.filter(function (event) { return !event.allDay; }),
        periodStart: startOfView,
        periodEnd: endOfView
    }).sort(function (eventA, eventB) {
        return eventA.start.valueOf() - eventB.start.valueOf();
    }).map(function (event) {
        var eventStart = event.start;
        var eventEnd = event.end || eventStart;
        var startsBeforeDay = eventStart < startOfView.toDate();
        var endsAfterDay = eventEnd > endOfView.toDate();
        var hourHeightModifier = (hourSegments * segmentHeight) / MINUTES_IN_HOUR;
        var top = 0;
        if (eventStart > startOfView.toDate()) {
            top += moment(eventStart).diff(startOfView, 'minutes');
        }
        top *= hourHeightModifier;
        var startDate = startsBeforeDay ? startOfView : moment(eventStart);
        var endDate = endsAfterDay ? endOfView : moment(eventEnd);
        var height = endDate.diff(startDate, 'minutes');
        if (!event.end) {
            height = segmentHeight;
        }
        else {
            height *= hourHeightModifier;
        }
        var bottom = top + height;
        var overlappingPreviousEvents = previousDayEvents.filter(function (previousEvent) {
            var previousEventTop = previousEvent.top;
            var previousEventBottom = previousEvent.top + previousEvent.height;
            if (top < previousEventTop && previousEventTop < bottom) {
                return true;
            }
            else if (top < previousEventBottom && previousEventBottom < bottom) {
                return true;
            }
            else if (previousEventTop <= top && bottom <= previousEventBottom) {
                return true;
            }
            return false;
        });
        var dayEvent = {
            event: event,
            height: height,
            width: eventWidth,
            top: top,
            left: overlappingPreviousEvents.length * eventWidth,
            startsBeforeDay: startsBeforeDay,
            endsAfterDay: endsAfterDay
        };
        if (height > 0) {
            previousDayEvents.push(dayEvent);
        }
        return dayEvent;
    }).filter(function (dayEvent) { return dayEvent.height > 0; });
    var width = Math.max.apply(Math, dayViewEvents.map(function (event) { return event.left + event.width; }));
    var allDayEvents = getEventsInPeriod({
        events: events.filter(function (event) { return event.allDay; }),
        periodStart: startOfView,
        periodEnd: endOfView
    });
    return {
        events: dayViewEvents,
        width: width,
        allDayEvents: allDayEvents
    };
};
exports.getDayViewHourGrid = function (_a) {
    var viewDate = _a.viewDate, hourSegments = _a.hourSegments, dayStart = _a.dayStart, dayEnd = _a.dayEnd;
    var hours = [];
    var startOfView = moment(viewDate).startOf('day').hour(dayStart.hour).minute(dayStart.minute);
    var endOfView = moment(viewDate).endOf('day').startOf('minute').hour(dayEnd.hour).minute(dayEnd.minute);
    var segmentDuration = MINUTES_IN_HOUR / hourSegments;
    var startOfDay = moment(viewDate).startOf('day');
    for (var i = 0; i < HOURS_IN_DAY; i++) {
        var segments = [];
        for (var j = 0; j < hourSegments; j++) {
            var date = startOfDay.clone().add(i, 'hours').add(j * segmentDuration, 'minutes');
            if (date >= startOfView && date < endOfView) {
                segments.push({
                    date: date,
                    isStart: j === 0
                });
            }
        }
        if (segments.length > 0) {
            hours.push({ segments: segments });
        }
    }
    return hours;
};
//# sourceMappingURL=calendarUtils.js.map